package kim.jeonghyeon.simplearchitecture.plugin

import com.squareup.kotlinpoet.*
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import org.jetbrains.kotlin.backend.common.descriptors.isSuspend
import org.jetbrains.kotlin.descriptors.CallableMemberDescriptor
import org.jetbrains.kotlin.descriptors.Modality
import org.jetbrains.kotlin.descriptors.ValueParameterDescriptor
import org.jetbrains.kotlin.js.descriptorUtils.getJetTypeFqName
import org.jetbrains.kotlin.types.KotlinType
import org.jetbrains.kotlin.types.isNullable
import java.io.File

class ApiClassProcessor(
    val buildPath: String,
    val sourceSets: List<SourceSetOption>,
    val isNative: Boolean
) :
    ClassElementFindListener {

    val apiAnnotationName = Api::class.java.name

    override fun onClassElementFound(element: ClassElement) {
        //already processed classes come out several times
        // - different target, different build variant(debug, release)
        // - all the classes which can be referred by several target will be handled several times.
        if (element.isValid()) {
            element.createClassFile()
        }
    }

    private fun ClassElement.isValid(): Boolean = hasAnnotation(apiAnnotationName)
            && classDescriptor.modality == Modality.ABSTRACT//Todo limitation : can't detect if it's abstract class or interface
                && isTopLevelClass

    private fun ClassElement.createClassFile() {
        FileSpec.builder(packageName, simpleName + "Impl")
            .addComment("GENERATED by Simple Api Plugin")
            .addType(asClassSpec())
            .build()
            .writeTo(File(getGeneratedClassPath()))
    }

    fun ClassElement.getGeneratedClassPath(): String {
        //todo native source set can't be separated for generated class
        // source set is not detected when subplugin's option is applied.

        //find target by matching source folder
        val sourceSetName = if (isNative) NATIVE_TARGET_NAME else sourceSets.first {
            it.sourcePathSet.any {
                path.startsWith(it)
            }
        }.name

        return generatedFilePath(buildPath, sourceSetName)
    }

    fun ClassElement.asClassSpec(): TypeSpec {
        //classDescriptor member information
        // name : class's name
        // modality : ABSTRACT for interface and abstract class
        // module.simpleName() : "$module_$build_type" ex)common_release
        // containingDeclaration.name : package's last folder's name
        // containingDeclaration.fqNameSafe.asString() : package full name. ex) kim.jeonghyeon.simplearchitecture.plugin
        // containingDeclaration.platform : [{"targetVersion":"JVM_1_8","targetPlatformVersion":{},"platformName":"JVM"}] todo check if other platform?
        // containingDeclaration.parents.joinToString(","){it.name.asString() : "\u003ccommon_release\u003e". able to check it's build type debug or release
        // source.containingFile.name : file name including '.kt'

        return TypeSpec.classBuilder(ClassName(packageName, simpleName + "Impl"))
            .addSuperinterface(ClassName(packageName, simpleName))
            .addFunctions(functions()
                .filter { it.isValidFunction() }
                .map { it.asFunctionSpec(simpleName) }
            ).build()
    }

    fun CallableMemberDescriptor.isValidFunction(): Boolean = modality == Modality.ABSTRACT

    fun CallableMemberDescriptor.asFunctionSpec(className: String): FunSpec {
        //name : function's name
        //origin.name : same with `name`
        //source.containingFile.name : file name including '.kt'
        //valueParameters[0].type.toString() : parameter's type
        //returnType?.memberScope?.getFunctionNames()?.joinToString { it.asString() } : shows functions of the type
        //returnType?.memberScope?.getVariableNames()?.joinToString { it.asString() } : shows variables of the type
        check(isSuspend) { "@Api : abstract function should be suspend on $className.$name'" }

        val builder = FunSpec.builder(name.toString())
            .addModifiers(KModifier.SUSPEND)
            .addModifiers(KModifier.OVERRIDE)
            .addParameters(valueParameters.map { it.asParameterSpec() })
        returnType?.asTypeName()?.let {
            builder.returns(it)
        }

        return builder.build()
    }
}

private fun ValueParameterDescriptor.asParameterSpec(): ParameterSpec =
    ParameterSpec.builder(name.asString(), type.asTypeName()).build()

fun KotlinType.asTypeName(): TypeName {
    val className: ClassName = createClassName().let {
        if (isNullable()) it.copy(true) else it
    }

    if (arguments.isNotEmpty()) {
        return arguments
            .map { it.type.asTypeName() }
            .let { className.parameterizedBy(*it.toTypedArray()) }
    }
    return className
}

fun KotlinType.createClassName(): ClassName {
    //on Jvm, packageName is java.util, instead of kotlin, even if source set is common
    //todo currently only HashMap is checked.
    // need to check other standard classes
    if (packageName == "java.util") {
        if (name == "HashMap") {
            return ClassName("kotlin.collections", name)
        }
    }

    return ClassName(
        packageName, name
    )
}

val KotlinType.packageName: String get() = getJetTypeFqName(false).substringBeforeLast(".")
val KotlinType.name: String get() = getJetTypeFqName(false).substringAfterLast(".")