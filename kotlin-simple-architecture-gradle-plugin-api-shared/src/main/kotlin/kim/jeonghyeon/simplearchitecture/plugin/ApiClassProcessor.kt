package kim.jeonghyeon.simplearchitecture.plugin

import com.google.gson.Gson
import com.squareup.kotlinpoet.*
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import org.jetbrains.kotlin.backend.common.descriptors.isSuspend
import org.jetbrains.kotlin.descriptors.CallableMemberDescriptor
import org.jetbrains.kotlin.descriptors.Modality
import org.jetbrains.kotlin.descriptors.ValueParameterDescriptor
import org.jetbrains.kotlin.js.descriptorUtils.getJetTypeFqName
import org.jetbrains.kotlin.types.KotlinType
import org.jetbrains.kotlin.types.isNullable
import java.io.File

class ApiClassProcessor(val buildPath: String, val sourceSets: List<SourceSetOption>) :
    ClassElementFindListener {

    val apiAnnotationName = Api::class.java.name

    //todo delete previous generated classes.

    override fun onClassElementFound(element: ClassElement) {
        //todo check if already called class is call again

        //todo this is called several times. maybe because ApiComponentRegistrar calls several times. is it really required?
        //todo check if native class is also recognized

        if (element.isValid()) {
            element.createClassFile()
        }
    }

    private fun ClassElement.isValid(): Boolean = hasAnnotation(apiAnnotationName)
            && classDescriptor.modality == Modality.ABSTRACT
                && isTopLevelClass
    //todo check if the class is interface or abstract class.

    private fun ClassElement.createClassFile() {
        FileSpec.builder(packageName, simpleName + "Impl")
            .addComment("GENERATED by Simple Api Plugin")
            .addType(asClassSpec())
            .build()
            .writeTo(File(getGeneratedClassPath()))
        //todo how to set generated file's folder as source path.
    }

    fun ClassElement.getGeneratedClassPath(): String {
        //todo LIMITATION : it won't work properly on the below cases. need to find the way how to figure out build path.
        // class is only on some build type or flavor
        //Remove <> from module name, and remove '_release', '_debug' in case it exists.

        //todo how to detect target and compilation name?
        // on Native, it's not possible to get path.

        //find target by matching source folder
        val sourceFolderName = sourceSets.firstOrNull {
            it.sourcePathSet.any {
                path.startsWith(it)
            }
        }?.name

        if (sourceFolderName == null) {
            log("path", path, sourceSets.flatMap { it.sourcePathSet })
        }

        return "$buildPath/generated/source/simpleapi/$sourceFolderName"
    }

    //todo if class is inside other class? then containingDeclaration seems other class. if it's inner class. ignore it.
    //todo check findPackage()


    fun ClassElement.asClassSpec(): TypeSpec {
        //classDescriptor member information
        // name : class's name
        // modality : ABSTRACT for interface and abstract class
        // module.simpleName() : "$module_$build_type" ex)common_release
        // containingDeclaration.name : package's last folder's name
        // containingDeclaration.fqNameSafe.asString() : package full name. ex) kim.jeonghyeon.simplearchitecture.plugin
        // containingDeclaration.platform : [{"targetVersion":"JVM_1_8","targetPlatformVersion":{},"platformName":"JVM"}] todo check if other platform?
        // containingDeclaration.parents.joinToString(","){it.name.asString() : "\u003ccommon_release\u003e". able to check it's build type debug or release
        // source.containingFile.name : file name including '.kt'

        return TypeSpec.classBuilder(ClassName(packageName, simpleName + "Impl"))
            .addSuperinterface(ClassName(packageName, simpleName))
            .addFunctions(functions()
                .filter { it.isValidFunction() }
                .map { it.asFunctionSpec(simpleName) }
            ).build()
    }

    fun CallableMemberDescriptor.isValidFunction(): Boolean = modality == Modality.ABSTRACT

    fun CallableMemberDescriptor.asFunctionSpec(className: String): FunSpec {
        //name : function's name
        //origin.name : same with `name`
        //source.containingFile.name : file name including '.kt'
        //valueParameters[0].type.toString() : parameter's type
        //returnType?.memberScope?.getFunctionNames()?.joinToString { it.asString() } : shows functions of the type
        //returnType?.memberScope?.getVariableNames()?.joinToString { it.asString() } : shows variables of the type
        check(isSuspend) { "@Api : abstract function should be suspend on $className.$name'" }

        val builder = FunSpec.builder(name.toString())
            .addModifiers(KModifier.SUSPEND)
            .addModifiers(KModifier.OVERRIDE)
            .addParameters(valueParameters.map { it.asParameterSpec() })
        returnType?.asTypeName()?.let {
            builder.returns(it)
        }

        return builder.build()
    }
}

private fun ValueParameterDescriptor.asParameterSpec(): ParameterSpec =
    ParameterSpec.builder(name.asString(), type.asTypeName()).build()

fun KotlinType.asTypeName(): TypeName {
    val className: ClassName = ClassName(
        packageName,
        name
    ).let {
        if (isNullable()) it.copy(true) else it
    }

    if (arguments.isNotEmpty()) {
        return arguments
            .map { it.type.asTypeName() }
            .let { className.parameterizedBy(*it.toTypedArray()) }
    }
    return className
}

val KotlinType.packageName: String get() = getJetTypeFqName(false).substringBeforeLast(".")
val KotlinType.name: String get() = getJetTypeFqName(false).substringAfterLast(".")


fun log(vararg text: Any?) {
    println("TestHyun : ${Gson().toJson(text)}")
}